#!/usr/bin/env bash
# -----------------------------------------------------------------------------
# Part of the OntoPortal Virtual Appliance Project
# https://ontoportal.org
#
# Author: Alex Skrenchuk (@alexskr)
# Copyright (c) 2025 Stanford University and the OntoPortal Alliance
# SPDX-License-Identifier: Apache-2.0
#
# Description
# Generates a self-signed SSL certificate with SANs (Subject Alternative Names)
# for OntoPortal appliances duing initial deployment/bootstrap process.
set -euo pipefail

EC2META=/usr/local/ontoportal/bin/ec2meta

# --- Require sudo ---
if [[ $EUID -ne 0 ]]; then
  echo "‚ùå This script must be run as root or with sudo."
  echo "Try: sudo $(basename "$0")"
  exit 1
fi

# --- Description & Help ---
show_help() {
  local code="${1:-0}"
  cat <<EOF
OntoPortal SSL Certificate Generation Script
--------------------------------------------
Generates a self-signed SSL certificate with SANs (Subject Alternative Names)
for OntoPortal appliances.

üí° In production, use a valid certificate from a trusted Certificate Authority.

Usage:
  $(basename "$0") [--hostname=host1] [--hostname=host2 ...]
                   [--add-to-trust] [--no-localhost]

Options:
  --hostname=HOST       Add a DNS SAN (can be used multiple times)
  --add-to-trust        Install the generated cert into the system trust store
  --no-localhost        Do NOT include localhost, 127.0.0.1, or ::1 in SAN
  --help                Show this help message

EOF
  exit "$code"
}

# --- Argument Parsing ---
HOSTNAMES=()
ADD_TO_TRUST=false
INCLUDE_LOCALHOST=true

for arg in "$@"; do
  case "$arg" in
    --hostname=*)
      HOSTNAMES+=("${arg#*=}")
      ;;
    --add-to-trust)
      ADD_TO_TRUST=true
      ;;
    --no-localhost)
      INCLUDE_LOCALHOST=false
      ;;
    --help)
      show_help 0
      ;;
    *)
      echo "‚ùå Unknown option: $arg" >&2
      show_help 1
      ;;
  esac
done

# --- Fallback to EC2 or local hostname if none provided ---
if [[ ${#HOSTNAMES[@]} -eq 0 ]]; then
  if command -v /usr/local/ontoportal/bin/ec2meta &>/dev/null && ec2meta is-aws; then
    fallback_hostname=$(ec2meta public-hostname || ec2meta local-hostname)
    if [[ -n "$fallback_hostname" ]]; then
      HOSTNAMES+=("$fallback_hostname")
      echo "‚ÑπÔ∏è  Using EC2 metadata hostname: $fallback_hostname"
    else
      fallback_hostname=$(hostname -f)
      HOSTNAMES+=("$fallback_hostname")
      echo "‚ö†Ô∏è  EC2 metadata hostname not found, falling back to: $fallback_hostname"
    fi
  else
    fallback_hostname=$(hostname -f)
    HOSTNAMES+=("$fallback_hostname")
    echo "‚ÑπÔ∏è  Using system hostname: $fallback_hostname"
  fi
fi

COMMON_NAME="${HOSTNAMES[0]}"
echo "üîê Certificate CN: $COMMON_NAME"

# --- OS Detection & Path Setup ---
if [ -f /etc/debian_version ]; then
    OS="Debian"
    CERT_FILE="/etc/ssl/certs/ssl-cert-snakeoil.pem"
    KEY_FILE="/etc/ssl/private/ssl-cert-snakeoil.key"
    TRUST_STORE="/usr/local/share/ca-certificates/snakeoil.crt"
    UPDATE_TRUST_COMMAND="update-ca-certificates"
    CHOWN_COMMAND="chown root:ssl-cert"
elif [ -f /etc/redhat-release ]; then
    OS="RedHat"
    CERT_FILE="/etc/ssl/certs/localhost.crt"
    KEY_FILE="/etc/pki/tls/private/localhost.key"
    TRUST_STORE="/etc/pki/ca-trust/source/anchors/snakeoil.crt"
    UPDATE_TRUST_COMMAND="update-ca-trust extract"
    CHOWN_COMMAND=":" # No-op
else
    echo "‚ùå Unsupported OS. Only Debian-based or RedHat-based systems are supported."
    exit 1
fi

# --- Collect SAN candidates ---
IP=$(ip -4 route get 1.1.1.1 | awk '/src/ {print $7; exit}')
PTR_NAME=$(dig +short -x "$IP" | sed 's/\.$//')

AWS_PUBLIC_DNS=""
AWS_PRIVATE_DNS=""
if command -v ec2meta &>/dev/null && ec2meta is-aws; then
  AWS_PUBLIC_DNS=$(ec2meta public-hostname || true)
  AWS_PRIVATE_DNS=$(ec2meta local-hostname || true)
fi

ALT_NAMES_FILE=$(mktemp)
i=1

# --- Localhost SANs unless skipped ---
if [[ "$INCLUDE_LOCALHOST" == true ]]; then
  echo "DNS.${i} = localhost" >> "$ALT_NAMES_FILE"; ((i++))
  echo "IP.${i} = 127.0.0.1" >> "$ALT_NAMES_FILE"; ((i++))
  echo "IP.${i} = ::1" >> "$ALT_NAMES_FILE"; ((i++))
else
  echo "‚ö†Ô∏è  Skipping localhost SANs per --no-localhost"
fi

# --- User/auto-detected hostnames
for hn in "${HOSTNAMES[@]}"; do
  echo "DNS.${i} = ${hn}" >> "$ALT_NAMES_FILE"
  ((i++))
done

[[ -n "$PTR_NAME" ]]        && echo "DNS.${i} = ${PTR_NAME}" >> "$ALT_NAMES_FILE" && ((i++))
[[ -n "$AWS_PUBLIC_DNS" ]]  && echo "DNS.${i} = ${AWS_PUBLIC_DNS}" >> "$ALT_NAMES_FILE" && ((i++))
[[ -n "$AWS_PRIVATE_DNS" ]] && echo "DNS.${i} = ${AWS_PRIVATE_DNS}" >> "$ALT_NAMES_FILE" && ((i++))
[[ -n "$IP" ]]              && echo "IP.${i} = ${IP}" >> "$ALT_NAMES_FILE" && ((i++))

# --- OpenSSL Config ---
OPENSSL_CONFIG=$(mktemp)
trap 'rm -f "$OPENSSL_CONFIG" "$ALT_NAMES_FILE"' EXIT

cat > "$OPENSSL_CONFIG" <<EOF
[req]
distinguished_name=req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
CN = ${COMMON_NAME}
O  = OntoPortal (Local)

[v3_req]
subjectAltName = @alt_names

[alt_names]
$(cat "$ALT_NAMES_FILE")
EOF

# --- Generate Certificate ---
openssl req -x509 -nodes -days 3650 \
  -newkey rsa:2048 \
  -keyout "$KEY_FILE" \
  -out "$CERT_FILE" \
  -config "$OPENSSL_CONFIG" \
  -extensions v3_req

chmod 640 "$KEY_FILE"
$CHOWN_COMMAND "$KEY_FILE"

echo "‚úÖ Self-signed certificate created."

# --- Show CN + SAN
echo -n "üîê Common Name (CN): "
CN=$(openssl x509 -in "$CERT_FILE" -noout -subject | awk -F 'CN=' '{print $2}' | sed 's/^ *//')
echo "${CN:-<not found>}"

echo "üåê Subject Alternative Names (SAN):"
openssl x509 -in "$CERT_FILE" -noout -text | awk '/Subject Alternative Name/{f=1; next} /X509v3/{f=0} f'

# --- Optionally Add to Trust Store ---
if [[ "$ADD_TO_TRUST" = true ]]; then
  echo "üîÑ Adding certificate to system trust store..."
  cp "$CERT_FILE" "$TRUST_STORE"
  if $UPDATE_TRUST_COMMAND; then
    echo "‚úÖ Certificate successfully added to trust store."
  else
    echo "‚ùå Failed to update system trust store using '$UPDATE_TRUST_COMMAND'."
    exit 1
  fi
fi

